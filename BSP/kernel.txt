Timebase frequency
==================
the time for one tick
the value is set in dts, and Linux will know how to measure time

for example:
timebase-frequency=1000000
1ms per tick -> 10 tick for 1 second
when Linux receive 10 tick, it knows 1 second passed

when the value is set larger, it means the platform run very fast
and Linux will wait for more ticks for 1 second to pass

If the value is set wrong,
for example, FPGA runs 100MHz but set the value to 1GHz
Linux will wait 10 times ticks when dealing with timer
So when you run application that ues alarm/timer(sleep)
It will spend a log more time to run.


Spinlock test
==================
1. CONFIG_PROVE_LOCKING
   detect the potential deadlock when booting
   Lock debugging: prove locking correctness

2. LOCK_TORTURE_TEST
   Spinlock torture test

tweek:
==================
* Modify stack frames size

  Error message:
  -----------
  warning: the frame size of xxxx bytes is larger than 1024 bytes
  -----------

  Reason:
  Local variable in function take too large size (larger than frame size)

  Solution:
  1. Reduce local variable size in function
  2. Enlarge frame size in kernel config
     ------
     Kernel hacking  --->
         Compile-time checks and compiler options  --->
           (1024) Warn for stack frames larger than (needs gcc 4.4)
     ------
     You can change it to 2048 or 4096


HOWTO: build
==================
0. Enter Kernel directory
# cd /path/to/kernel

1. Set the cross compiler:
# export CROSS_COMPILE=/path/to/toolchain/aarch64-linux-gnu-
# export ARCH=arm64

2. Build kernel and dtb
# make mrproper
# make <board>_defconfig
# make Image dtbs

kernel image: arch/arm64/boot/Image
dtb: arch/arm64/boot/dts/

For 32bit ARM cpu, change as below
# export CROSS_COMPILE=arm-linux-gnueabi-
# export ARCH=arm
# make zImage dtbs


linux code explanation
==================
https://eeepage.info/sk_buff-packet


Check config
==================
# zcat /proc/config.gz

Check bootargs
==================
# cat /proc/cmdline
loglevel=8 initcall_debug earlycon=sifive,0x20000000 console=ttySIF0,115200

Config that enable earlycon
==================
# zcat /proc/config.gz| grep CONFIG_SERIAL_EARLYCON
CONFIG_SERIAL_EARLYCON=y
CONFIG_SERIAL_EARLYCON_RISCV_SBI=y


debug
==================
* Build kernel with below config, and you can use backtrace in gdb
  CONFIG_DEBUG_INFO
  ---
  Kernel hacking
   --> Compile-time checks and compiler options
   ----> Compile the kernel with debug info
  ---

* Check if vmlinux contains debug message
  objdump -d -Sl vmlinux
